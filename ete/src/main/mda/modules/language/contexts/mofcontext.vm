################################################################################
##                                                                            ##
## Generates a convenience class to instantiate a parser for a simple String  ##
##                                                                            ##
################################################################################
package fr.insset.jeanluc.ete.${dialect.i2lc($projectName)}.impl;



import fr.insset.jeanluc.ete.${projectName.toLowerCase()}.AttributeNav;
import fr.insset.jeanluc.ete.${projectName.toLowerCase()}.${dialect.i2uc($projectName)}Context;
import fr.insset.jeanluc.ete.${projectName.toLowerCase()}.${dialect.i2uc($projectName)}Expression;
import fr.insset.jeanluc.ete.${projectName.toLowerCase()}.Step;
import fr.insset.jeanluc.ete.${projectName.toLowerCase()}.VariableDefinition;
import fr.insset.jeanluc.ete.meta.model.core.NamedElement;
import fr.insset.jeanluc.ete.meta.model.emof.Feature;
import fr.insset.jeanluc.ete.meta.model.emof.MofClass;
import fr.insset.jeanluc.ete.meta.model.emof.MofOperation;
import fr.insset.jeanluc.ete.meta.model.emof.MofParameter;
import fr.insset.jeanluc.ete.meta.model.emof.MofProperty;
import fr.insset.jeanluc.ete.meta.model.mofpackage.EteModel;
import fr.insset.jeanluc.ete.meta.model.types.MofType;
import fr.insset.jeanluc.util.factory.FactoryRegistry;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import javax.annotation.Generated;
// import org.antlr.v4.runtime.ANTLRInputStream;
// import org.antlr.v4.runtime.CommonTokenStream;


/**
 *
 * @author jldeleage
 */
@Generated("ete - jean-luc@insset.fr  ete/src/main/mda/modules/language/contexts/mofcontext.vm")
public class ${dialect.i2uc($projectName)}ContextImpl implements ${dialect.i2uc($projectName)}Context<${dialect.i2uc($projectName)}Expression> {




    public ${dialect.i2uc($projectName)}ContextImpl() {
        // We must start with at least a stack frame
        push();
        FactoryRegistry.getRegistry().registerDefaultFactory("let", VariableDefinitionImpl.class);
    }


    public ${dialect.i2uc($projectName)}ContextImpl(EteModel inModel, MofClass inContextualClass, NamedElement inContext) {
        this();
        init(inModel , inContextualClass, inContext);
    }

    /**
     * Sets the MODEL, SELF, CONTEXT and ROOT variables
     */
    public void init(EteModel inModel, MofClass inContextualClass, NamedElement inContext) {
        // These three variables keep their values throughout the whole
        // expression parsing
        set(MODEL, inModel);
        set(SELF, inContextualClass);
        set(CONTEXT, inContext);
        // The root variable is updated when we enter a subexpression
        // In such a case it takes the value of CURRENT
        // It takes the contextual class in the initial navigation
        set(ROOT, inContextualClass);
        if (inContext instanceof MofOperation) {
            MofOperation operation = (MofOperation) inContext;
            MofType      resultType = operation.getType();
            if (resultType == null) {
                return;
            }
            VariableDefinition  result;
            try {
                result = (VariableDefinition) FactoryRegistry.newInstance("let");
            } catch (InstantiationException | IllegalAccessException ex) {
                throw new RuntimeException(ex);
            }
            result.setName("result");
            result.setType(resultType);
            set(RESULT, result);
            Collection<MofParameter> ownedParameter = operation.getOwnedParameter();
            for (MofParameter aParameter : ownedParameter) {
                __set(aParameter.getName(), aParameter);
            }
        }   //inContext is a MofOperation
    }

    public ${dialect.i2uc($projectName)}Expression resolve(String inString) {
        ${dialect.i2uc($projectName)}Expression obj = __resolve(inString);
        set(CURRENT, obj.getType().getRecBaseType());
        return obj;
    }


    protected ${dialect.i2uc($projectName)}Expression __resolve(String inString) {
        ${dialect.i2uc($projectName)}Expression   result = null;
        MofType   current = (MofType)resolveVariable(CURRENT);
        if (current == null) {
            result = resolveProperty(inString, (MofClass)resolveVariable(ROOT));
            if (result != null) {
                return result;
            }
        }
        else {
            result = resolveProperty(inString, (MofClass)current);
            return result;
        }
        Object variable = resolveVariable(inString);
        if (variable == null) {
            variable = resolveModelInstance(inString);
        }
        if (variable instanceof ${dialect.i2uc($projectName)}Expression) {
            return (${dialect.i2uc($projectName)}Expression)variable;
        }
        if (result instanceof NamedElement) {

        }
        return null;
    }


    //========================================================================//

/*
    @Override
    public void set${dialect.i2uc($projectName)}(String inString, ${dialect.i2uc($projectName)}Expression inValue) {
        set(inString, inValue);
    }
*/

    public void __set(String inString, Object inValue) {
        try {
            VariableDefinition  variable = (VariableDefinition) FactoryRegistry.newInstance("let");
            variable.setName(inString);
            variable.setValue(inValue);
            set(inString, variable);
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void set(String inString, Object inValue) {
        stack.peekFirst().put(inString, inValue);
    }

    @Override
    public void remove(String inString) {
        stack.peekFirst().remove(inString);
    }



    //========================================================================//


    public final void push() {
        Map<String, Object> map = new HashMap<>();
        stack.addFirst(map);
    }

    public void pop() {
        stack.removeFirst();
    }


    //========================================================================//


    public   ${dialect.i2uc($projectName)}Expression resolveProperty(String inString, MofClass from) {
        Feature feature = from.getOwnedAttribute(inString);
        String  symbol  = ".att";
        if (feature == null) {
            feature = from.getOwnedOperation(inString);
            symbol = ".op";
        }
        if (feature != null) {
            try {
                Step nav = (Step) FactoryRegistry.newInstance(symbol);
                nav.setToFeature(feature);
                nav.setType(feature.getType());
                return nav;
            } catch (InstantiationException | IllegalAccessException ex) {
                throw new RuntimeException(ex);
            }
        }
        return null;
    }




    protected   Object resolveVariable(String inString) {
        Iterator<Map<String, Object>> iterator = stack.iterator();
        while (iterator.hasNext()) {
            Map<String, Object> map = iterator.next();
            Object expression = map.get(inString);
            if (expression != null) {
                return expression;
            }
        }        
        return null;
    }




    protected   Object resolveModelInstance(String inString) {
        EteModel    model = (EteModel)resolveVariable(MODEL);
        if (model != null) {
            return model.getElementByName(inString);
        }
        return null;
    }


    //========================================================================//


    private Deque<Map<String, Object>>     stack = new LinkedList<>();

}


