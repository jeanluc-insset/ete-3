################################################################################
##                                                                            ##
## Generates an abstract tree builder for any Expression Language             ##
## An instance of this class is a visitor for these Expressions. It takes any ##
## expression concrete tree and returns the matching abstract tree.           ##
##                                                                            ##
## Usage :                                                                    ##
##  XxxParser             parser  = XxxParserFactory.newParser(inExpression); ##
##  XxxExpressionContext  ctx          = parser.xxxExpression();              ##
##  TreeBuilder           treeBuilder  = new TreeBuilder(inContext);          ##
##  XxxExpression         expression   = treeBuilder.visitXxxExpression(ctx); ##
##                                                                            ##
## A future release will be more generic to be usable with any language       ##
##                                                                            ##
################################################################################
package fr.insset.jeanluc.ete.${dialect.i2lc($projectName)}.impl;



import fr.insset.jeanluc.ete.meta.model.emof.MofClass;
import fr.insset.jeanluc.ete.meta.model.emof.MofParameter;
import fr.insset.jeanluc.ete.meta.model.emof.MofProperty;
import fr.insset.jeanluc.ete.meta.model.mofpackage.MofPackage;
import fr.insset.jeanluc.ete.meta.model.mofpackage.PackageableElement;
import fr.insset.jeanluc.ete.meta.model.types.Classifier;
import fr.insset.jeanluc.ete.meta.model.types.MofType;
import fr.insset.jeanluc.ete.meta.model.types.TypedElement;
import fr.insset.jeanluc.ete.meta.model.types.collections.MofCollection;
import fr.insset.jeanluc.ete.${dialect.i2lc($projectName)}.${dialect.i2uc($projectName)}Parser;
import fr.insset.jeanluc.ete.${dialect.i2lc($projectName)}.${dialect.i2uc($projectName)}ParserBaseVisitor;
import fr.insset.jeanluc.ete.${dialect.i2lc($projectName)}.*;
import fr.insset.jeanluc.util.factory.FactoryMethods;
import fr.insset.jeanluc.util.factory.FactoryRegistry;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.Generated;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.RuleNode;



/**
 * Generates an abstract tree builder.
 * An instance of this class is a visitor for ${dialect.i2uc($projectName)}Expressions. It takes any
 * ${dialect.i2uc($projectName)}Expression concrete tree and returns the matching abstract tree.
 *
 * Usage : <code><pre>
${dialect.i2uc($projectName)}Parser            parser             = ${dialect.i2uc($projectName)}ParserFactory.newParser(aString);
${dialect.i2uc($projectName)}ExpressionContext ctx                = parser.${dialect.i2lc($projectName)}Expression();
TreeBuilder          treeBuilder        = new TreeBuilder(inContext);
${dialect.i2uc($projectName)}Expression        abstractExpression = treeBuilder.visit${dialect.i2uc($projectName)}Expression(ctx);
</pre></code>
 *
 */
@Generated("ete - jean-luc@insset.fr  ete/src/main/mda/modules/language/tree-builder.vm")
public class TreeBuilder extends ${dialect.i2uc($projectName)}ParserBaseVisitor<${dialect.i2uc($projectName)}Expression> {



    public TreeBuilder(MofPackage inModel, TypedElement inContext) {
        this(inModel, inContext, new HashMap<>());
    }
    
    public TreeBuilder(MofPackage inModel, TypedElement inContext, Map<String, VariableDefinition> inVariables) {
        variables = inVariables;
        model = inModel;
        context = inContext;
        if (context instanceof fr.insset.jeanluc.ete.meta.model.emof.MofOperation) {
            fr.insset.jeanluc.ete.meta.model.emof.MofOperation operation
                    = (fr.insset.jeanluc.ete.meta.model.emof.MofOperation)context;
            contextClass.push(operation.getOwningMofClass());
            for (MofParameter aParameter : operation.getOwnedParameter()) {
                // TODO : use a factory
                VariableDefinition  parameterDefinition = new VariableDefinitionImpl();
                parameterDefinition.setIdentifier(aParameter.getName());
                parameterDefinition.setType(aParameter.getType());
                variables.put(aParameter.getName(), parameterDefinition);
            }
        }
        else {
            contextClass.push((MofClass)context);
        }

        FactoryRegistry registry = FactoryRegistry.getRegistry();
#foreach($aClass in $current.classes)
#if (${aClass.getValueOf("literalType")})
        registry.registerDefaultFactory("${aClass.getValueOf("literalType")}", ${aClass.name}Impl.class);
#elseif (${aClass.getValueOf("symbol")})
        registry.registerDefaultFactory("${aClass.getValueOf("symbol")}", ${aClass.name}Impl.class);
#end
#end
        registry.registerDefaultFactory("self", SelfImpl.class);
        registry.registerDefaultFactory("Navigation", NavigationImpl.class);
        registry.registerDefaultFactory(CollectionOperationExpression.class, CollectionOperationExpressionImpl.class);
        registry.registerDefaultFactory(VariableReference.class, VariableReferenceImpl.class);
    }


    @Override
    public ${dialect.i2uc($projectName)}Expression visit${dialect.i2uc($projectName)}Expression(${dialect.i2uc($projectName)}Parser.${dialect.i2uc($projectName)}ExpressionContext ctx) {
        navigable = new Stack<>();
        return super.visit${dialect.i2uc($projectName)}Expression(ctx); //To change body of generated methods, choose Tools | Templates.
    }


#foreach ($aClass in $current.classes)
#if ($aClass.getValueOf("literalType"))
// LITERAL TYPE : ${aClass.getValueOf("literalType")}
#end
#if ($aClass.getValueOf("symbol"))
#set ($kind = $aClass.getValueOf("kind"))
#if (! $kind)
#set ($kind = "nokind")
#end
#set ($arity = $aClass.getValueOf("arity"))
    @Override
    // The $aClass class contains the tag value "symbol" with the value of {$aClass.getValueOf("symbol")}
    public ${dialect.i2uc($projectName)}Expression visit${aClass.name}Expression(${dialect.i2uc($projectName)}Parser.${aClass.name}ExpressionContext ctx) {
        List<ParseTree> children = ctx.children;
        if (children.size() == 1) {
            return children.get(0).accept(this);
        }
        try {
#set ($fragment = "fragments/" + $kind + ".vm")
#parse ($fragment)
        }
        catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

#end
#end



    //========================================================================//


    //========================================================================//

    private     MofPackage                              model;

    /**
     *  Should be an instance of MofClass or (Mof)Operation.
     */
    private     TypedElement                            context;

    /**
     * An expression can contains sub-expressions. For example<br>
     * <code>pilot[</code>
     * The first item of the stack is defined by :<br><code>
     * context instanceof MofClass ==&gt; context == contextClass<br>
     * context instanceof Operation ==&gt; context.getOwningMofClass() == contextClass</code>
     */
    private     Stack<Classifier>                       contextClass = new Stack<>();

    private     Stack<Navigable>                        navigable;

    private     Map<String, VariableDefinition>         variables = new HashMap<>();

    private     String                                  currentNavOperator;

}

